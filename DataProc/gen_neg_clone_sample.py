import json
import random
import sys
import os
import html

# Configurations
# Input file must contain 'func_id' (generated by gen_init_train_sample.py)
# DEFAULT_INPUT = "data/nicad_camel_clone_data_small.jsonl" # Input with func_id
DEFAULT_INPUT = "data/nicad_camel_clone_data.jsonl" # Input with func_id
OUTPUT_JSONL = "data/nicad_camel_neg_samples.jsonl"       # Consistent naming
OUTPUT_TXT = "data/nicad_camel_neg_samples.txt"           # TXT format output
OUTPUT_HTML = "display_neg_sample.html"
OUTPUT_MD = "data/display_neg_sample.md"                  # Markdown Report

def generate_html_report(pairs, output_file=OUTPUT_HTML):
    """
    Generates an HTML report to visualize the generated negative pairs side-by-side.
    """
    html_content = [
        "<html><head><style>",
        "body { font-family: sans-serif; margin: 20px; background-color: #f9f9f9; }",
        "h2 { color: #333; }",
        ".pair-container { background: white; border: 1px solid #ddd; margin-bottom: 30px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }",
        ".pair-header { font-weight: bold; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #eee; color: #555; }",
        ".code-row { display: flex; gap: 20px; }",
        ".code-col { flex: 1; min-width: 0; }",
        ".meta-info { font-size: 0.85em; color: #666; margin-bottom: 5px; background: #f0f0f0; padding: 5px; border-radius: 4px; }",
        "pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ccc; overflow-x: auto; font-size: 0.8em; font-family: Consolas, monospace; height: 300px; }",
        ".label-badge { background-color: #e74c3c; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; vertical-align: middle; }",
        "</style></head><body>",
        f"<h2>Generated Negative Samples (Label 0) - Total {len(pairs)} Pairs</h2>",
        "<p>These pairs represent functions from <b>different</b> clone groups (different logic).</p>"
    ]

    for i, pair in enumerate(pairs, 1):
        f1 = pair['func1']
        f2 = pair['func2']
        meta = pair['meta']

        info1 = f"<b>ID:</b> {f1.get('func_id', 'N/A')}<br><b>ClassID:</b> {meta['classid1']}<br><b>File:</b> {f1.get('file', 'N/A')}<br><b>Name:</b> {html.escape(f1.get('qualified_name', 'Unknown'))}"
        info2 = f"<b>ID:</b> {f2.get('func_id', 'N/A')}<br><b>ClassID:</b> {meta['classid2']}<br><b>File:</b> {f2.get('file', 'N/A')}<br><b>Name:</b> {html.escape(f2.get('qualified_name', 'Unknown'))}"

        code1 = html.escape(f1.get('code', ''))
        code2 = html.escape(f2.get('code', ''))

        html_content.append(f"""
        <div class="pair-container">
            <div class="pair-header">
                Pair #{i} <span class="label-badge">Negative (Non-Clone)</span>
            </div>
            <div class="code-row">
                <div class="code-col">
                    <div class="meta-info">{info1}</div>
                    <pre>{code1}</pre>
                </div>
                <div class="code-col">
                    <div class="meta-info">{info2}</div>
                    <pre>{code2}</pre>
                </div>
            </div>
        </div>
        """)

    html_content.append("</body></html>")

    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(html_content))
    print(f"HTML report generated: {output_file}")

def generate_markdown_report(pairs, output_file=OUTPUT_MD):
    """
    Generates a Markdown table report for GitHub README embedding.
    """
    md_lines = [
        "### üîç Negative Sample Inspection (generated)",
        "",
        "| Pair ID | Function A (Source) | Function B (Target) |",
        "| :--- | :--- | :--- |"
    ]

    for i, pair in enumerate(pairs, 1):
        f1 = pair['func1']
        f2 = pair['func2']
        
        # Format code to be compact (first 5 lines only) for the table
        # We replace pipes | with HTML entity to avoid breaking the markdown table
        code1_snippet = "<br>".join(f1.get('code', '').split('\n')[:5]).replace("|", "&#124;") + "..."
        code2_snippet = "<br>".join(f2.get('code', '').split('\n')[:5]).replace("|", "&#124;") + "..."
        
        # Meta info
        meta1 = f"<b>ID:</b> `{f1.get('func_id')}`<br>`{f1.get('qualified_name')}`"
        meta2 = f"<b>ID:</b> `{f2.get('func_id')}`<br>`{f2.get('qualified_name')}`"

        row = f"| **#{i}** | {meta1}<br><pre>{code1_snippet}</pre> | {meta2}<br><pre>{code2_snippet}</pre> |"
        md_lines.append(row)

    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(md_lines))
    print(f"Markdown report generated: {output_file}")

def verify_negative_samples(file_path):
    """
    Verifies that the generated negative samples truly belong to different clone groups.
    """
    if not os.path.exists(file_path):
        print(f"Error: File '{file_path}' not found.")
        return

    print(f"\n--- Verifying Negative Samples: {file_path} ---")
    
    total_lines = 0
    errors = 0
    valid_pairs = 0

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line: continue
                
                total_lines += 1  # <--- FIXED: Increment here
                
                parts = line.split('\t')
                
                # Format Check: Must be ID1 [tab] ID2 [tab] Label
                if len(parts) != 3:
                    print(f"[Line {line_num}] Format Error: Expected 3 columns, found {len(parts)}.")
                    errors += 1
                    continue
                
                id1, id2, label = parts
                
                # Label Check: Must be '0'
                if label != '0':
                    print(f"[Line {line_num}] Label Error: Expected '0', found '{label}'.")
                    errors += 1
                    continue

                # Parse Clone Group IDs (Format: groupID_globalID)
                try:
                    group1 = id1.split('_')[0]
                    group2 = id2.split('_')[0]
                except IndexError:
                    print(f"[Line {line_num}] ID Format Error: IDs must contain '_'. Got ({id1}, {id2})")
                    errors += 1
                    continue

                # LOGIC CHECK: Are they from different groups?
                if group1 == group2:
                    print(f"[Line {line_num}] ‚ùå LOGIC FAILURE: Pair is from the SAME group ({group1}). This is a POSITIVE sample labeled as 0!")
                    print(f"   -> {id1} vs {id2}")
                    errors += 1
                else:
                    valid_pairs += 1

    except Exception as e:
        print(f"Error reading file: {e}")
        return

    # Final Report
    print(f"Total Lines Checked: {total_lines}")
    print(f"Valid Negative Pairs: {valid_pairs}")
    
    if errors == 0:
        print("‚úÖ SUCCESS: All pairs are valid negative samples (different clone groups).")
    else:
        print(f"‚ùå FAILED: Found {errors} invalid pairs.")

def generate_negative_samples(input_file, output_jsonl, output_txt):
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found.")
        print("Tip: Make sure to run 'gen_init_train_sample.py' first to generate IDs.")
        return

    print(f"--- Loading data from: {input_file} ---")
    
    # 1. Load Data
    groups = {}     # {classid: [func1, func2, ...]}
    flat_funcs = [] # list of (classid, func_data)
    
    total_positive_pairs = 0

    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line: continue
                try:
                    data = json.loads(line)
                    class_id = data.get("classid")
                    sources = data.get("sources", [])
                    
                    if class_id is None or not sources:
                        continue
                        
                    groups[class_id] = sources
                    
                    # Calculate potential positive pairs (nC2) for this group
                    n = len(sources)
                    if n > 1:
                        total_positive_pairs += (n * (n - 1)) // 2
                    
                    for src in sources:
                        flat_funcs.append((class_id, src))
                        
                except json.JSONDecodeError:
                    continue
    except Exception as e:
        print(f"Error reading file: {e}")
        return

    # --- Detailed Calculation Logic ---
    total_funcs = len(flat_funcs)
    total_possible_combinations = (total_funcs * (total_funcs - 1)) // 2 if total_funcs > 1 else 0
    max_negative_pairs = total_possible_combinations - total_positive_pairs

    print(f"Loaded {len(groups)} groups with {total_funcs} total functions.")
    
    print(f"\n=== Detailed Calculation of Dataset Capacity ===")
    print(f"1. Total Functions (N): {total_funcs}")
    print(f"   - We have {total_funcs} unique functions in the dataset.")
    print(f"   - Total possible pairs (Universe) = N * (N - 1) / 2")
    print(f"   - {total_funcs} * {total_funcs - 1} / 2 = {total_possible_combinations:,} pairs")

    print(f"\n2. Max Possible Positive Samples (Clones): {total_positive_pairs:,}")
    print(f"   - Calculation: Sum of pairs within each clone group.")
    print(f"   - Formula: Sum( size * (size - 1) / 2 ) for all groups.")
    print(f"   - This represents all pairs where Label = 1.")

    print(f"\n3. Max Possible Negative Samples (Non-Clones): {max_negative_pairs:,}")
    print(f"   - Calculation: Universe - Positives")
    print(f"   - Formula: {total_possible_combinations:,} - {total_positive_pairs:,} = {max_negative_pairs:,}")
    print(f"   - This represents all pairs where Label = 0.")
    print(f"================================================\n")
    
    if len(groups) < 2:
        print("Error: Need at least 2 clone groups to generate negative samples.")
        return

    # 2. Generate Negative Pairs
    target_neg_count = total_positive_pairs if total_positive_pairs > 0 else 10
    
    if target_neg_count > max_negative_pairs:
        print(f"Warning: Target {target_neg_count} exceeds max possible negatives. Adjusting to {max_negative_pairs}.")
        target_neg_count = max_negative_pairs

    print(f"--- Generating {target_neg_count} Negative Samples (Balanced) ---")
    
    generated_pairs_list = []
    seen_pairs = set()
    attempts = 0
    max_attempts = target_neg_count * 50 
    
    while len(generated_pairs_list) < target_neg_count and attempts < max_attempts:
        attempts += 1
        f1 = random.choice(flat_funcs)
        f2 = random.choice(flat_funcs)
        id1, data1 = f1
        id2, data2 = f2
        
        if id1 != id2:
            k1 = data1.get("func_id") or (data1.get("qualified_name", "") + str(data1.get("range", "")))
            k2 = data2.get("func_id") or (data2.get("qualified_name", "") + str(data2.get("range", "")))
            pair_key = tuple(sorted((k1, k2)))
            
            if pair_key not in seen_pairs:
                seen_pairs.add(pair_key)
                pair_entry = {
                    "label": 0,
                    "func1": data1,
                    "func2": data2,
                    "meta": {"classid1": id1, "classid2": id2}
                }
                generated_pairs_list.append(pair_entry)

    print(f"Done. Generated {len(generated_pairs_list)} unique negative pairs.")

    # 3. Save Files
    try:
        with open(output_jsonl, 'w', encoding='utf-8') as out_f:
            for p in generated_pairs_list:
                out_f.write(json.dumps(p) + "\n")
        print(f"JSONL saved to: {output_jsonl}")
    except Exception as e:
        print(f"Error writing JSONL: {e}")

    try:
        with open(output_txt, 'w', encoding='utf-8') as txt_f:
            count = 0
            for p in generated_pairs_list:
                fid1 = p['func1'].get('func_id')
                fid2 = p['func2'].get('func_id')
                if fid1 and fid2:
                    txt_f.write(f"{fid1}\t{fid2}\t0\n")
                    count += 1
        print(f"TXT saved to: {output_txt} ({count} lines)")
    except Exception as e:
        print(f"Error writing TXT: {e}")

    # 4. Generate Reports
    generate_html_report(generated_pairs_list)
    generate_markdown_report(generated_pairs_list)

if __name__ == "__main__":
    input_path = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_INPUT
    
    # Cleanup old outputs
    for f in [OUTPUT_JSONL, OUTPUT_HTML, OUTPUT_TXT, OUTPUT_MD]:
        if os.path.exists(f): os.remove(f)
        
    # Step 1: Generate
    generate_negative_samples(input_path, OUTPUT_JSONL, OUTPUT_TXT)
    
    # Step 2: Verify
    verify_negative_samples(OUTPUT_TXT)
